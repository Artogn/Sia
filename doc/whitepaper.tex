\newcommand{\numhosts}{192}
\newcommand{\storageperhost}{256GB}
\newcommand{\childrenperparent}{192}
\newcommand{\fortynine}{$\frac{n}{2} - 1$}
\newcommand{\fiftyone}{$\frac{n}{2} + 1$}
\newcommand{\filechecksize}{256 bytes}
\newcommand{\maxcorruption}{80\%}

\documentclass[twocolumn]{article}

\begin{document}

\title{Sia : Decentralized, Compensated, Self-Repairing Computer Storage}

\author{
{\rm David Vorick}\\
Rensselaer Polytechnic Institute
\and
{\rm Colin Rice}\\
Rensselaer Polytechnic Institute
}

\maketitle

\subsection*{Abstract}
Sia is a decentralized platform for computer storage.
Host computers contribute storage and bandwidth in return for Sia's internal cryptocurrency - Siacoin.
In addition to receiving compensation from the users, host computers also mine siacoins in proportion to the volume of storage they contribute.
Clients acquire siacoins (either by being hosts or through a currency exchange) to exchange for storage space and download bandwidth on the Sia network.
The cost of renting storage is set using a supply and demand algorithm.
Sia is a cryptosystem that is secure even when \fortynine \space of the hosts are dishonest and malicious.
Sia is built out of many small blockchains arranged in a tree structure.
Blockchains operate using a concensus algorithm instead of proof-of-work.
To join a blockchain, you must have proof-of-storage equivalent to \storageperhost.

\section{Introduction - Nontechnical}

Sia is a decentralized platform for storing data on the internet.
With only a few kilobytes of overhead, any file can be stored on the Sia network.
Sia supports anonymity, and guaruantees uptime for the files.
Files can be fetched with only a few hundred milliseconds of latency.
Files are random-access, meaning a piece of the file can be downloaded without fetching the whole file.
All files are seeded by \numhosts \space peers, meaning files can be uploaded and downloaded at high speed.
Sia minimizes file redundancy while maximizing speed and security, making Sia competitive with centralized services.

Files are stored by hosts in exchange for Siacoins.
The price of storage is set algorithmically according to supply and demand.
Siacoins are mined on the Sia network and are the only currency that can be used to purchase Sia storage.
This constraint provides stability to the price of the siacoin - the price of the coin is tethered to the price of Sia storage.
Siacoin is a superset of Bitcoin.

Files can be stored in two modes.
\begin{itemize}
	\item Immutable - once uploaded, the file can never be altered, and the size of the file is constant.
	At the end of the file, there is a pointer to another file, which can contain information about updates to the original file.
	This pointer can be null.
	Immutable files are appropriate for shared data.
	\item Mutable - the contents of the file can be changed by anyone with permission.
	The original contents of the file are permanently lost after a change is made.
	Mutable files are appropriate for personal/private data.
\end{itemize}

Files have a balance of siacoins, which is used to pay the hosts that store the file.
Each block, a volume of siacoins is removed from the balance according to the current price of storage.
When the balance runs out, the file is deleted.
Anybody can increase the balance at any time by sending more siacoins to the file.
There is no way to remove a file from the network aside from waiting until the balance depletes.
There is no way to extract coins from the balance - once sent to a file, siacoins are locked into a single purpose.
These constraints protect against censorship.

Sia can be used as a more efficient replacement for many of todays services.
These services include Bittorrent, Bitcoin, and Filelockers.
Sia can also be used as a place to host embedded web content.
On fast connections, Sia can be used as a replacement for hard drives - computers would only need enough local storage to boot and connect to the internet.

One major advantage of Sia is that all shared files only need to be hosted once, yet no central service needs to be trusted or depended on.
Another advantage of Sia is that you only need to rent as much storage as you are actively using - more storage can be rented on-the-fly.

% I may have included too much information in this section, but it's important to give an overview of the whole network. Pretty much every topic discussed needs to be covered, but it may not need to be so detailed.
\section{Introduction - Technical}

Sia is built out of many small blockchains of \numhosts \space hosts each.
These blockchains participate in a deterministic consensus algorithm instead of using a block mining algorithm such as proof-of-work.
Blockchains are assembled randomly from hosts on the network - hosts cannot control which blockchain they are participating in.
Each host must be contributing \storageperhost \space to the network in order to be placed in a blockchain.
A single machine with lots of storage can operate as many hosts simultaneously - as long as each host has \storageperhost \space of unique storage.
Blockchains will be honest as long as at least \fiftyone \space of the hosts within the blockchain are honest.

Storage is only valid once there are files uploaded to the network to store.
This is because the proof-of-storage algorithm requires actual data on which to perform verifications.
The proof-of-storage algorithm makes use of the fact that data is redundant - each host is storing different Reed-Solomon coded pieces of the files uploaded to the network.
By gathering file pieces from each host, the network can use the pieces to check for corruption.

Each blockchain has a set of files which it tracks.
As files are added and deleted, the network performs load-balancing.
When the total amount of available storage on the network drops below a certain threshold, a new blockchain is created.
The load balancing algorithms then pick a bunch of files to store on the new blockchain.
If the network rises above a certain threshold of available storage, a blockchain is chosen to be deleted.
That blockchain then load-balances every file to other blockchains and terminates.

If there are many hosts waiting to join blockchains, and not enough new files for the hosts to store, the price of storage will drop.
Dropping the price not only affects supply and demand, it also means that existing files will be on the network for longer.
If the amount of available storage on Sia is low and there are not many hosts for creating new blockchains, the price of storage will increase.
Increasing the storage not only affects supply and demand, it also means that existing files will be deleted faster.

% I need help writing this paragraph
Blockchains are organized into a tree that manages the needs of the network.
Parent blockchains have aggregate information about their children - such as how much data is being stored by each child.
Only the leaf blockchains actually store files - all the other blockchains are designed to be very lightweight.
The root blockchain determines the network price, and also knows how many new hosts there are and how much free space there is on the network.
When the root blockchain needs to do something such as create new blockchains, it delegates the work to its children.
Those children delegate work to their children, until the action hits the leaf layer, where it is carried out.

% This one too
The same happens in the reverse direction.
When a leaf blockchain deletes a file, it tells its parent, who then updates its aggreagate resource.
Parent blockchains are in charge of load-balancing their children, and they wait for their parents to load balane them.

% And this one too - heck, probably all of them
Existing systems use only a single blockchain, where very node is aware of every event on the network.
This will not scale well, especially in a system attempting to track potentially billions of files and hundreds of millions of daily downloads.
Using a tree means that a leaf blockchain only needs to be aware of its parent, and its grandparent, all the way up to the root.
Because parent blockchains are very lightweight, and because there are \childrenperparent \space children per layer, this is very little information to track.
Because parent blockchains track aggregate resources, a leaf blockchain can be certain the the network approves of its funds without needing to know the state of the entire network.

Siacoins and wallets are treated in much the same way as files.
Wallets consume space on the network, and get charged for the space they consume.
When wallets send money to a different blockchain, the transaction propagates through the tree.
Information is aggregated, meaning that the parent blockchain will only say how many coins have moved between children - it will not say which wallet the coins are from or which wallet the coins are for.
This compression is necessary to keep the amount of information sent through the root blockchain at a minimum.
This compression also means that there needs to be another way to determine which wallets incoming siacoins are for.

This is accomplished by having leaf blockchains directly talk to eachother.
When a wallet in one leaf blockchain is sending money to a wallet on another leaf blockchain, the first blockchain will send a message indicating that coins are going to be sent.
The second blockchain then claims to its parent the correct volume of blockchains, using the sent message as proof.
The parent then knows how many coins to claim.

Blockchains can look up the direct communcation address of other blockchains through a DHT.
All leaf blockchains participate in the DHT, and only leaf blockchains participate in the DHT.
This allows blockchains to find eachother in log(n) time without sending high volumes of messages through their parents, and without needing to store the direct communication address of every blockchain in the network.

Sia has an indictment framework - every action by a host or blockchain is signed and verified by a large number of other hosts or blockchains.
If any host or blockchain is caught performing an illegal action, that host or blockchain is fined and thrown from the network.
To make fines successful, fines must be equal to the amount of damage caused, and hosts/blockchains must always have enough siacoins to pay the maximum possible fine that they could incur (called a deductible).

Sia assumes that \fiftyone \space of the hosts on the network are honest.
If \fortynine \space of the hosts are corrupted, a large volume of blockchains will also be corrupted.
Parent blockchains are not immune from this corruption.
The indictment framework, plus a series of checks and balances insures that the network can operate without loss even if as many as \maxcorruption \space of the blockchains are dishonest, and even if as many as \maxcorruption \space of the hosts in a particular blockchain are dishonest.

If only \fortynine \space of the hosts are corrupted, it is extremely unlikely that the network will ever have a blockchain with more than \maxcorruption \space of the hosts corrupted, and it is also extremely unlikely that an attacker will corrupt more than \maxcorruption \space of the blockchains in the network.

\section{Consensus Blockchains}

Concensus blockchains are formed from \numhosts \space hosts all storing \storageperhost.
Each blockchain hosts a set of files and wallets that are unique to that blockchain (each object only appears on a single blockchain).
Blockchains have a 'state', which is a representation of the current status of the network.
The state is updated in blocks, which are produced in a concensus algorithm.

Blocks are composed of 'heartbeats', which is an update package from a host.
Each block, every host must submit a heartbeat.
This is how the host proves that they are online, and also how the host performs proof-of-storage.

Each block, every host must include the following:
\begin{itemize}
	\item A proof that the host is storing files
	\item A random string to produce entropy for the blockchain
	\item All updates/transactions submitted to the host
	\item Timing information to keep the blockchain synchronized
\end{itemize}

The blockchain algorithm assumes that up to \fortynine \space of the hosts in the blockchain are dishonest and malicious.
Each block, honest hosts must be guaranteed to have their heartbeat included.
Furthermore, every honest host must be guaranteed to include the same set of heartbeats, so that the blockchain can maintain a state of consistency.
These things are guaranteed by the following algorihtm:

\begin{enumerate}
	\item All hosts send their heartbeats to all other hosts.
	\item All hosts tell the other hosts which heartbeats they received, and sign that they received these heartbeats.
	In this step, hosts will fill in gaps in each other's list of heartbeats.
	\item All hosts tell the other hosts which heartbeats they know were seen by at least \fiftyone \space of the hosts on the network, and include the list of signatures proving that the hosts actually saw the heartbeats.
\end{enumerate}

By the end of the third step, the honest hosts will be guaranteed to have all received the same set of heartbeats that have been seen by \fiftyone \space of the hosts on the network.
All hosts will therefore produce the same block.
The process can then restart for the next block.

\section{Concensus Algorithm Proof}

Assumptions:
\begin{itemize}
	\item 51\% of the network is honest.
	\item All honest hosts can communicate freely. (no DOS attacks)
	\item The network is synchronized, meaning all hosts can complete each step within a known limited timeframe, and hosts can self-correct for drift
\end{itemize}

In step 1, every honest host will get heartbeats from every other honest host.
If \fiftyone hosts are honest, every honest host is guaranteed to have their heartbeat seen by at least \fiftyone hosts.

In step 2, every host tells each other host which heartbeats they have seen, and attatch a signature that they saw the heartbeat.
This means that any heartbeat that was seen by any honest host will be seen by every other honest host.

In step 3, every host tells each other host which heartbeats they got which were seen by at least \fiftyone hosts.
This is to guarantee that the heartbeat was seen by at least 1 honest host in the previous step.
If it was seen by at least 1 honest host, then every honest host is guaranteed to have received it in this step.
Therefore, every honest host is guaranteed to include every heartbeat that was seen by \fiftyone hosts in the second step.

\section{Proof of Access}

Hosts are required to store \storageperhost. 
Heartbeats include proof that the hosts are actually storing the data.

Each block, a random \filechecksize \space segment of the \storageperhost \space is selected to be 

Clients upload files to the Sia network, and then hosts must store them.
A part of the heartbeat contains proof that the host has access to the stored file.
Before a file is uploaded to the network, it is split into \numhosts \space pieces using Reed-Solomon coding.
The client can choose how redundant the file should be.
Reed-Solomon coding works such that you pick how many total pieces there are (\numhosts) and then how many pieces are needed to recover the file.
The client can choose any number between 1 and (\numhosts \space - 1), however if enough hosts go offline such that the file cannot be fully recovered, the file will be tossed from the network.
Hosts prove that they have access to their piece of the file by including their piece of the file in their heartbeat update.
The Reed-Solomon coding of the pieces means that by decoding the pieces, honest hosts can detect which pieces are incorrect or corrupted.
This means that honest hosts can also repair corrupted file pieces and replace hosts that go offline.

It is too expensive to include all \storageperhost \space in every heartbeat.
Instead, randomness is used.
One 1kb slice is chosen from the \storageperhost \space stack at random to be included in the heartbeat.
A host that does not have the entire \storageperhost \space stack is likely to have a missing piece randomly selected.
If the host is missing 50\% of the file, each block the host has a 50\% chance of getting caught at being corrupt.

Additionally, when all the honest hosts share the contents of their heartbeats with the dishonest hosts, they leak information.
The dishonest hosts will be able to rebuild their piece of the file by completing the erasure coding algorithm.
To prevent this, access proofs are done in two steps.
In the first step, hosts submit a hash of their piece of the file.
In the second step, hosts reveal the file piece that produces the hash.
This forces dishonest hosts to lock in their piece of the file before they see what the other file pieces consist of; no informaiton is leaked.
Each block, both steps occur.
The second step looks at the first step from the previous block to confirm.

Indictable offenses: a host submits a hash, and then in the next block submits a file piece that does not match the submitted hash.

Protection against corrupted uploads: it is possible that a host has the file that they were uploaded and yet still fail the corruption test.
They will be indicted for storing incorrect data, and the indictment will be incorrect.
Hosts can prove themselves innocent by uploading the entire file piece as well as the hash of the file piece that was created when the file was uploaded.
If the hosts file piece matches the hash, and the hosts indicted slice correctly matches the file piece, then the file is determined to have been corrupted at upload.
The host is acquitted and the file piece is corrected, the host then has the correct file piece.

Problems: proof of access is exactly that, there is still a problem of delegation.
Dishonest hosts can collaborate.
Since files have a redundancy, dishonest hosts can communicate and remove that redundancy, enabling them to claim that they are storing larger file pieces than they are actually storing.
The proposed solution to this problem is 'false redundancy punishment', which shall be discussed later in the paper.

Also, there is an undiscussed problem of looping storage, where a dishonest host pretends to store information but actually just stores it back on the Sia network. Then, when the host needs to prove access to the storage, he just downloads it from the other blockchain that's holding it. This results in free mining for the host. The way to fight this is to make it more expensive to download a file than you earn from mining it. Then hosts that participate in this behavior will be losing money.

I want to note explicity that there is not a problem of uploading false files.
Assuming that 51\% of the swarm is honest, a false file will need to pay for storage on 51\% of honest hosts, because they will store the entire false file.
Mining will be hard capped such that hosting a file can mine a maximum of 20\% of the total income for the file.
The remaining income must come from the client paying the network price for the file.

\section{Entropy}

Each block, a random file segment must be selected.
This means that the blockchain needs an unpredictable way to produce entropy, otherwise a dishonest host could look ahead and only store the pieces that it knows will be "randomly" selected.
Each block, every host will be required to produce a random string that is 32 bytes in length.
There are no requirements on how this is to be done, but it is assumed that honest hosts will have a legitamate method for producing random strings.

Just like the proof of access, the random strings will have two stages.
In the first stage, only the hash of the randomly generated string will be revealed.
In the second stage, the actual random string will be revealed, and then all of the random strings will be appended deterministically and then hashed to produce the final random string for the block.

By determining entropy this way, we guarantee that if even a single host produces a random string, the final string will also be random.

This method of generating entropy is vulnmerable to an attack: dishonest hosts can intentionally withdraw from the network to influence the outcome of the random number.
The way to prevent this is to make sure that the penalty for missing a heartbeat is more expenive than favorably generating entropy for a potential 80\% of dishonest hosts.
There will be a penalty for missing heartbeats, and it will sufficiently satisfy this attack prevention mechanism.

\section{A Tree of Blockchains}

Explain that blockchains are organized into trees, operate on assumption of 51\% dishonest blockchains, talk about parent and child relationships. Talk about detecting a comporomised parent, and immediately replacing them to minimize damage to the network.

\section{Dishonest Blockchains}

Talking about how hosts need to be forcefully removed when hosts are dropped, talking about honest hosts resigning, etc.

\section{Aggregate Transactions}

Explain how aggregate transactions work, aggregate storage. Attack vectors such as dishonest swarms sending dishonest spends. Prove detection of dishonesty and integrety of aggregation given 51\% honest swarms.

\section{Aggregation DHT}

Explain the DHT that allows blockchains to talk to eachother without flooding the parent with communication.

\section{Stuff to be integrated later}

There is an entire scripting system, as well as potentially a cacheing system or something like that. I would really like to see an emergency home for dynamic pages built into this system (even if it's a crappy and slow home) because Tor has been compromised and currently there is nowhere else to go.

\section{Implications}

An entire section dedicated to talking about the implications of universally available cheap cloud storage, especially when it's encrypted and decentralized.
Then I can also talk about the implications of the scripting system.
We can expand here on services that might succeed on Sia, being able to take advantage of its unique features.
Bittorrent, onion routing, anonymous money, etc.

An entire paragraph needs to be dedicated to talking about the economic implications of the cryptocurrency.
Min and max price, etc.

\end{document}
