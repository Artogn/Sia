\newcommand{\numhosts}{192}
\newcommand{\storageperhost}{256GB}

\newcommand{\childrenperparent}{192}

\newcommand{\fortynine}{$\frac{n}{2} - 1$}
\newcommand{\fiftyone}{$\frac{n}{2} + 1$}

\newcommand{\filechecksize}{256 bytes}

\newcommand{\maxcorruption}{85\%}
\newcommand{\inversemaxcorruption}{15\%}
\newcommand{\maxredundancy}{6$\frac{2}{3}$}

\newcommand{\maxslicesize}{1mb}

% the real set of commands - above to be replaced
\newcommand{\quorumsize}{128}
\newcommand{\defaultM}{28}
\newcommand{\hostincomefee}{3.9\%}
\newcommand{\maxsegmentsize}{1mb}
\newcommand{\participantvolume}{8gb}
\newcommand{\stepduration}{15 seconds}

\documentclass[twocolumn]{article}

\begin{document}
\frenchspacing

\title{Sia : Decentralized, Compensated, Self-Repairing Computer Storage}

\author{
{\rm David Vorick}\\
Nebulous Labs
\and
{\rm Luke Champine}\\
Nebulous Labs
}

\maketitle

\subsection*{Abstract}
Sia is a decentralized platform for computer storage acting as a marketplace for storage.
On the supply side, host computers contribute storage in return for Sia's internal cryptocurrency - Siacoin.
On the demand side, consumers use Siacoin to rent storage space.
The price of storage is set by a market making algorithm that is sensitive to the volume of supply and demand.
Files on Sia are distributed to a large number of randomly selected hosts.
Erasure Coding is used to give the files redundancy, enabling files to be spread over hundreds of machines with highly reliable network redundancies as low as 1.2.
Spreading the files over hundreds of hosts means that files can be downloaded in parallel from hundreds of places and achieve high throughput.
As explored in the paper, Sia should be a cheaper and superior solution to cloud storage when compared against the existing centralized alternatives.

\section{Introduction}

Sia is a decentralized platform for storing data on the cloud.
The storage on Sia is block level, like an unformatted hard drive.
This makes Sia file system agnostic - you store information on Sia by setting and requesting arrays of bits.
It is very easy to put a file system such as NTFS or ext4 on top of Sia.
It is expected that the average user will not interact directly with Sia, but rather with an application such as a music player that streams directly from Sia.

Because Sia operates at the block level, it does not make as much sense to talk about files being stored on Sia.
Instead we talk about sectors of storage, a sector being a logical set of bits stored on Sia.
Files can be stored within sectors, across multiple sectors, or any other way that a file can be translated into a series of bits.
Sia is random access, which means you can download any part of a sector without needed to download the whole sector.

Each sector is given to \quorumsize{} machines that monitor the health of the sector.
If any of these machines goes offline, it is replaced by the network, keeping the sector available and in good health.
The sector is broken into \quorumsize{} segments, of which M are redundant, where M is chosen by the uploader.
Any M machines can go offline at the same time and the sector will still be recoverable - this is because Reed-Solomon coding is used.
If a machine goes offline or fails, it will be replaced by a new machine within a few hours, bringing the sector back up to its original redundancy.
Having a sector split between \quorumsize{} machines and being able to tolerate M faults every day means that even in scenarios of high paranoia M can be relatively small.

Reed-Solomon codes are maximum-distance separable.
This means that redundancy is maximally efficient.
For example, take a 100mb sector that gets broken up into 128 pieces with M=28.
You have 100 non-redundant pieces and 28 redundant pieces.
Of these, ANY 28 pieces can be lost and the full sector can still be recovered.
Together, all 128 pieces consume 128mb of physical storage.
The default value for M on Sia is \defaultM{}.

Each sector is stored on \quorumsize{} machines, and the sector can be downloaded in parallel from all of them.
This allows Sia to obtain very high throughput for downloads, even if each machine is only offering a little bandwidth.
Additionally, for situations requiring reduced latency, only the closest \quorumsize{} - M machines need to be contacted.
Because a random set of machines are hosting each sector, the closest \quorumsize{} - M machines are likely to be very close when M is large, regardless of the location of the downloader.

Each sector stored on Sia is accompanied by approximately 40kb of overhead that allows the network to monitor and error-check the sector.
Multiple files can be stored on a single sector; 40kb is not a minimum file size it is a minimum sector size.
Each sector is broken into \quorumsize{} segments after redundancy is added.
The maximum size of a segment is limited to \maxsegmentsize.
The maximum size of a sector therefore depends on the value of M, a larger M means a smaller maximum sector size.
Sectors are just a way for the network to orgainze, even though the maximum sector size is small, files and information can be stored across many sectors.
Optimizing for smaller sectors means that each file is stored on that many more machines, which means the benefits of parallel downloads are increased.

Another property of Sia is that it becomes very difficult to censor data.
Forcefully taking sectors off of the network requires corrupting or destroying more than M of the \quorumsize{} segments that compose the sector.
Because sectors on Sia are randomly distributed among a global set of hosts, it is very difficult for a single entity (even as powerful as the NSA) to attack a sufficient number of machines to corrupt a segment, especially when M is set to be large.

This network design results in some great features:
\begin{itemize}
	\item High Speed
	\item Low Latency
	\item High Robustness and Security
	\item Low Overhead
\end{itemize}

\section{Managing Sectors}

When uploading, a sector can either be encrypted or public.
Encrypted sectors are great for housing personal or private files.
Public sectors are great for hosting embeddable web content such as images and videos.
Any sector can be downloaded by anybody, and a sector may end up on any malicious machine.
The best way to protect a file or sector is to use client-side encryption.

Sectors can also be mutable or immutable.
The contents of a mutable sector can be altered at any time, but only by authorized parties.
Authorization is done using public key cryptography.
It is expected that most sectors will be mutable.
Immutable sectors cannot be altered after they have been uploaded.
This is achieved by authorizing nobody to edit a file.
Immutable sectors are appropriate for public and/or shared data - if you use a public sector, you want assurance that the data will be the same every time you access it.

Each sector is associated with a balance of siacoins, which is used to pay for the storage that the sector consumes.
Each block, a volume of siacoins is subtracted from the sector balance according to the current price of storage.
When the balance runs out, the sector is deleted, and space on the network is cleared for new data.
Anybody can add to the balance of a sector at any time, whether the sector is mutable or immutable.
Immutable sectors cannot be deleted from the network unless the siacoin balance fully depletes.

\section{Use Cases}

Sia can be used as an efficient replacement to many of today's web services.
One obvious example it BitTorrent.
With BitTorrent, every seeder needs essentially the entire file that's being seeded, resulting in a huge global redundancy of the file.
With Sia, a file only needs a small amount of redundancy to provide the same amount of throughput.
Another issue is that torrents die once the last seeder disappears.
The half life of a torrent can be as low as a few months.
With Sia, a file will stay around as long as the sectors are paid for.
Because anyone can pay for a sector, anyone can secure the longevity of a file on Sia without needing to go through the hassle of seeding it continuously.
Sia is not free, but neither is BitTorrent.
The cost of BitTorrent is seeding files, which consumes hard drive space and bandwidth.
Anybody with both of these resources can participant in Sia and gain Siacoins, enabling them to also download from Sia.
Sia is a comprehensive replacement for BitTorrent.

Sia makes sense as the storage layer for any streaming application.
This includes content embedded into web pages.
By embedding images and videos into Sia instead of hosting them on a centralized server, you can achieve lower storage costs, lower bandwidth costs, higher throughput, and equivalent (or even reduced) latencies.
Sia automatically acts as a CDN, meaning users across the world receive similar service to local users.
Sia could also be used for non-streaming applications, such as for save data in a video game, or even for loading new areas in a video game.

Sia is also elastic, meaning you only need to rent exactly as much storage as you are currently using.
Instead of needing to plan for the future and buying a 1TB drive, if you are only consuming 650GB then you can rent exactly 650GB of Sia storage.
You can expand the volume of storage you are renting at any time, within minutes.

On sufficiently fast connections, Sia could potentially be used as a replacement for hard drives.
The throughput on Sia can potentially exceed a gigabit per second, which is nearly as much throughput as an SSD.
The bottleneck would be latency, which would still be around a hundred milliseconds per request (except for sectors with very high redundancy).
By moving enough of your operating system into RAM, you can avoid this problem and replace your local hard drive.

\section{Economics}

Sia compensates hosts using a cryptocurrency.
This cryptocurrency, Siacoin, will be easily exchangeable for bitcoins and subsequently USD through a trustless exchange.
When the currency launches, the mining rate will be set to 10,000 siacoins per day.
The number of coins mined will decrease daily until the 4 year mark, at which point the network will mine coins such that the annual inflation rate is kept permanently at 5\%.
This means that there is no cap to the number of siacoins that will be produced.
No coins will be premined.

An inflationary model has been chosen for Siacoin to emphasize the current hosts on the network as opposed to the early adopters.
Initially, the number of coins generated will be very high, and the early adopters will be rewarded.
In the long run however we want the people actively contributing resources to the network to be the people that are most heavily rewarded.
We also believe that an inflationary model will result in a currency that is much less volatile.

Hosts on Sia will have two incomes: the first is the income from mining new coins, and the second is the income from rental payments.
This creates a unique dynamic where it's entirely possible that the raw cost of storage will be greater than the network price of storage due to the additional income hosts receive from mining.
Both incomes for hosts have a \hostincomefee{} fee which is distributed among the owners of Siastock.

Siastock is a 100\% premined currency that will be initially owned completely by the developers.
During an IPO or a pre-IPO, some percentage of Siastock will be traded for seed money.
Someone who owns 1\% of all Siatock will receive (1\% * \hostincomefee{}) = 0.039\% of all host income on the Sia network.
This model of developer and backer revenue has been chosen instead of premining because it enables us to make Sia inflationary while still having a guaranteed income.
It also makes it clearer exactly how much value is going towards the developers and stock owners.

The only way to access the storage on Sia is to use siacoins.
The storage on Sia has a certain value, and the only way to access that value is to use Siacoin.
If the price of Siacoin drops significantly, access to Sia resources becomes very cheap, which should in turn increase the demand for Siacoin and bring the price back up.
The internal value of Sia, combined with the fact that this value can only be accessed using Siacoin gives Siacoin an internal value that is roughly equivalent to the value of all the resources on Sia.
Siastock provides a guaranteed income that is equivalent a percentage of all host income in siacoins, Siastock also has an internal value.

% price ups and downs
% pricing Siacoin
% pricing Siastock

\section{Quorums}

When a machine joins the network, it joins the network as a set of participants.
Each participant contributes exactly \participantvolume{} to the network.
Each participant is then assigned to a random quorum on the network.
A quorum is a set of \quorumsize{} participants acting in consensus.
Each quorum has a 'State', which is the representation of the current state of the quorum.
For example, the state contains a list of participants, a list of sectors being stored, a list of wallets and balances, etc.
The state is updated in blocks.
Each block has one update, called a 'heartbeat', from every participant.
Each block, every participant is required to submit a heartbeat containing a minimum amount of information.
This information enables the quorum to:
\begin{itemize}
	\item Confirm that each participant is still online
	\item Perform proof-of-storage for each participant
	\item Confirm transactions
	\item Prevent dishonest activity
\end{itemize}

Achieving consensus requires a solution to the Byzantine Generals Problem.
Sia uses the solution with signed messages that is presented in the paper 'The Byzantine Generals Problem', with slight variations.
For each block:
\begin{enumerate}
	\item All participants send their heartbeat to all other participants, with a signature.
	This creates a 'signed heartbeat', which is a heartbeat followed by a list of signatures of everyone who has seen it.
	\item Each time a participant receives a signed heartbeat that they have not seen before, they add their signature to the list of signatures and send it to all other participants.
\end{enumerate}
To ensure termination, time constraints are added and heartbeats are send around in steps.
Each step lasts \stepduration{}.
All signed heartbeats received must have a number of signatures equivalent to the current step.
Each signature must be from a different participant in the quorum.
During step 1 for example, a heartbeat only needs to be signed by the participant producing the heartbeat.
If during step 1 a heartbeat is received with 2 or more signatures, this is acceptable, we only care that it has at least 1 signature.
There are \quorumsize{} steps total.
If a participant signs two different heartbeats from itself, that participant is dishonest and will be thrown from the network.
Because participants releasing more than two heartbeats are treated the same as participants releasing exactly two heartbeats, honest participants do not need to share more than two heartbeats per participant.
After the final step, all honest participants will have the same information and will be able to compile the same block.
The step is then reset to 1 and participants repeat the process for the next block.

The full algorithm:
\begin{enumerate}
	\item The step counter is set to 1, and increases by 1 every \stepduration{}.
	\item Each participant creates a heartbeat, signs it, and sends it to every other participant in the quorum.
	\item For each signed heartbeat that a participant receives
	\begin{enumerate}
		\item If the number of signatures on the signed heartbeat is less than the step counter, ignore.
		\item If there are multiple signatures from the same participant, ignore.
		\item If there are signatures from non-participants, ignore.
		\item If the receiving participant has already signed the signed heartbeat, ignore.
		\item If it is a heartbeat that has been seen before, ignore.
		\item If we have already seen two other heartbeats from the creator of this heartbeat, ignore.
		\item Add signature to the signed heartbeat and send it to all other participants in the quorum.
	\end{enumerate}
	\item When the step counter reaches \quorumsize{}, take all of the heartbeats and compile them into a block.
\end{enumerate}

The concern of the honest participant is getting the exact same set of heartbeats as every other honest participant in the quorum.
If all honest participants follow this algorithm, then the premise will hold.
If you are the first honest participant to receive a heartbeat but it has sufficient signatures compared to the step counter, then you can be sure that every other honest participant will get the heartbeat because you will send it to them.
If you are an honest participant receiving a heartbeat for the first time in the last step, you can be sure that all other honest participants have received the heartbeat because there will be a signature from every other participant in the quorum.
There is one exception if a dishonest participant shares more than two heartbeats.
In this case, every honest participant is guaranteed to receive at least two of the heartbeats.
They might not receive the others because honest participants stop sharing after they have shared two.
This is okay however, because the action taken by an honest participant will be to throw the dishonest participant from the network, regardless of the contents or quantity of the heartbeats.

\section{Block Compilation}

\section{Entropy}

\section{Overview}

Sia is built out of many small blockchains of \numhosts{} hosts each.
These blockchains participate in a deterministic consensus algorithm instead of using a block mining algorithm such as proof-of-work.
Blockchains are assembled randomly from hosts on the network - hosts cannot control which blockchain they are participating in.
Each host must be contributing exactly \storageperhost{} to the network in order to be placed in a blockchain.
A single machine operate as a group of hosts each contributing exactly \storageperhost{}, as long as the storage is unique.
Blockchains will be honest as long as at least a simple majority of the hosts within the blockchain are honest.

The proof-of-storage algorithm makes use of the fact that data is redundant - each host is storing different Reed-Solomon coded pieces of the files uploaded to the network.
By gathering file pieces from each host, the network can use the pieces to check for honesty and corruption simultaneously.

Each blockchain has a set of files which it tracks.
As files are added and deleted, the network performs load-balancing between blockchains to keep the file distribution even.

Hosts wanting to join the network are put into a queue, where they wait until there is sufficient storage demand to justify creating a new blockchain.
If there are many hosts joining the queue but few new files being added to the network, the price of storage will drop.
If there are many files being uploaded and few hosts joining the queue, the price of storage will increase.
The pricing algorithm tries to always keep hosts in a queue instead of putting files in a queue.

% I need help writing this paragraph
Blockchains are organized into a tree that manages the needs of the network.
Parent blockchains have aggregate information about their children - such as how much data is being stored by each child.
Only the leaf blockchains actually store files - all the other blockchains are designed to be very lightweight.
The root blockchain determines the network price, and also knows how many new hosts there are and how much free space there is on the network.
When the root blockchain needs to do something such as create new blockchains, it delegates the work to its children.
Those children delegate work to their children, until the action hits the leaf layer, where it is carried out.

% This one too
The same happens in the reverse direction.
When a leaf blockchain deletes a file, it tells its parent, who then updates its aggreagate resource.
Parent blockchains are in charge of load-balancing their children, and they wait for their parents to load balane them.

Using a tree of blockchains allows each host to participate in a lightweight blockchain that stores only a fraction of the information on the network.
Additionally, each host must only perform calculations on a fraction of the network.

The aggregate nature of the tree allows each host and wallet to verify that their segment of the network is honest, even though they cannot see every action occuring on the network.

Wallets take space on the network, and are charged the file price for existing on the network.
Each block, money is removed from the wallet and when the funds run out, the wallet is deleted.
As wallets only take up a few kilobytes, the amount charged is minimal.

When wallets send money to a different blockchain, the transaction propagates through the tree.
Information is aggregated, meaning that the parent blockchain will only say how many coins have moved between children; it will not say which wallet the coins are from or which wallet the coins are for.
This compression means that there needs to be a way to determine which wallets incoming siacoins are for, but it also means that the parent blockchains have a low maximum amount of work they have to perform per block.

To determine how aggregated transactions get divided, the sending blockchain messages the receiving blockchain, informing them that coins are incoming.
The receiving blockchain then claims the coins from the parent.

Blockchains can look up the direct communcation address of other blockchains through a DHT.
All leaf blockchains participate in the DHT.
This allows blockchains to find eachother in log(n) time without sending high volumes of messages through their parents, and without needing to store the direct communication address of every blockchain in the network.

Any time that a host is caught by the network performing an illegal action, the host will be fined.
The fine will be equal to or greater than the amount of damaged caused to the network.
To make sure that hosts can be fined, they are required to have a balance equal to or greater than the maximum possible fine - a 'security deposit'.
When a host leaves the network, the security deposit will be released.

The security measures in Sia ensure that an attacker cannot control which blockchain its hosts are participating; they are randomly distributed.
Sia assumes that only simple majority of the hosts on the network are honest.
If an attacker controls \fortynine{} of the hosts on the network, the attacker has a 50\% chance of controlling a particular blockchain, and will control roughly 50\% of the blockchains on the network.
Even controlling half of the hosts on the network, an attacker has a minimal chance of controlling more than \maxcorruption{} of the hosts in a particular blockchain.

In all interactions on Sia, it is assumed that blockchains are dishonest with 50\% probability, and that all blockchains have at least \inversemaxcorruption{} honest hosts.
Sia also has tools to detect dishonest actions by hosts and blockchains, which result in fines and being kicked from the network.

\section{Dishonest Blockchains}

We assume that hosts are randomly assigned to blockchains.
In a network where honest hosts only have a simple majority, an attacker can have the majority in many individual blockchains.

We can assume that all blockchains will have at least \inversemaxcorruption{} honest hosts given that half of the hosts on the network are honest.

\begin{equation}
\sum_{i=163}^{192} {192 \choose i} \; 0.5^{i} \; 0.5^{192-i} = 3.869\times10^{-24}
\end{equation}

If dishonest hosts have a majority in a blockchain, they can push honest hosts offline by preventing the honest heartbeats from getting the signatures required to be put in a block.
This allows, in one block, or spread through many blocks, a dishonest blockchain to push off all of the honest hosts.

To protect against this type of attack, each time a host is dropped from the network, 3 additional hosts are randomly selected to be dropped from the network.
Assuming worst case, this means that for each honest host, the next three hosts that get dropped will be half honest and half dishonest, for a total expected drop of 2.5 honest hosts and 1.5 dishonest hosts, or an expected ratio of 60\% honest hosts getting dropped.
Assuming that the network is half honest, the individual blockchain will converge to 60\% dishonest.

If individual blockchains converge to being 60\% dishonest, with high probability no blockchain will have less than \inversemaxcorruption{} honest hosts.

\begin{equation}
\sum_{i=163}^{192} {192 \choose i} \; 0.6^{i} \; 0.4^{192-i} = 5.392\times10^{-14}
\end{equation}

This means that for all blockchains, we can assume that at least \inversemaxcorruption{} hosts are honest.

\section{Proof of Access}

Each heartbeat, a host has to provide a proof that they have access to the file pieces that they are storing.
Each block, a random \filechecksize{} segment of the storage stack is chosen to be included in the heartbeat.
This segment will correspond to a portion of a file in a file ring.
Each host will include their portion of the file in their heartbeat, which means that in the block there is enough information to fully reconstruct a small portion of the file.
This will also reveal which hosts have the wrong data.

Only \filechecksize{} is requested each block because requesting more would greatly increase bandwidth requirements per block.
This small amount is sufficient because it is randomly selected.
If a host is missing a substantial portion of the file, it will only be a matter of time before some part of the missing portion is randomly selected.
This does mean that tiny corrupted sections of file can go undetected for a long time, but even small corruptions will eventually be detected and are unlikely to prevent file recovery.

We can assume that a malicious host will receive all of the honest heartbeats before submitting their own.
This means that, given sufficient redundnacy, a malicious host will be able to rebuild their piece of the file every step from the other heartbeats, can cna perform proof of access without actually storing anything.
To prevent that, this process is broken up across two stages.

In the first stage, hosts only submit the hash of the chosen segment prepended with their id.
This forces hosts to lock in what their file piece is before they see any information revealed from the other hosts.
In the second stage, hosts reveal what string produced the hash.
If they reveal a string that does not hash to the string submitted in stage 1, the host is considered corrupt.

% Penalties
If a host submits a second stage string that does not match their first stage hash, they are thrown from the swarm.

If a host submits a second stage string that is discovered as corrupt during decoding, an appeal is started.
The host must upload the entire slice that corresponds to the corrupted segment uploaded in the heartbeat.
The other hosts upload their chunks of the header data for that slice, which will contain the hash of the slice that the host is supposed to have.
If the slice matches the hash, and the segment uploaded matches the slice, then the piece is determined originally corrupt.
The host is aquitted, and the file itself is fined to pay for the bandwidth used during the appeal process.

Otherwise, the host treated as not having submitted a heartbeat.

If, during the appeal process, the blockchain is discovered dishonest, or a section of hosts is discovered dishonest, then the blockchain enters a panic state.

\section{Proof of Storage}

Storage is considered valid on the network if it follows two constraints:

\begin{itemize}
	\item It costs money to host files on the network.
	\item The storage is unique to the network.
\end{itemize}

The assumption for the first bullet point is that if a file costs money to upload, nobody will upload files that are not useful to them in some way.
A host will not upload a fake file to himself or the network if the act of doing so forces the host to operate at a net loss.
The second bullet point means that the host is not using Sia as it's source of storage, or that the host is not using a source that uses Sia as a source for storage.

The first point is protected by randomly collecting together swarms.
Any swarm will be composed of random sets of nodes, and will not have more than \maxcorruption{} dishonest hosts.
This means that any host attempting to use themselves as exclusive storage will have to host their files on at least \inversemaxcorruption{} honest hosts.
As long as the profit from mining on \maxcorruption{} of a fake file does not exceed the loss of paying for hosting on the \inversemaxcorruption honest hosts, there will be no incentive to do fake mining in this manner.
Therefore, a hard cap will be placed on the amount of coins that can be mined to satisfy this condition.

The second point is protected by the cost of downloads on the network.
Downloading a file costs money, and if you are to complete the proof of access steps in the heartbeat, you need to download a fraction of the file each heartbeat.
As long as the download system is constructed such that the cost of downloading repeatedly to perform heartbeat access proofs is greater than the reward from mining, this attack will not be a problem.
The system for pricing downloads has currently not been created, but it will be created with this constraint in mind.

% game theory stuff about why it's not beneficial for an incomplete minority to collaborate until they hit a critical mass
\begin{center}
Game theory stuff here
\end{center}

\section{The Problem of Delegation}

These proofs have a weak vulnerability; malicious hosts can collaborate and remove redundancy from the file.
Files have a redundancy so that they can be repaired if their hosts go offline.
A group of collaborating hosts can remove the redundancy from their file and store a single nonredundant copy.
When one of the group needs to do a proof on the file, the group builds the piece they need out of the pieces they have.

This is unhealthy for the network; if a single host goes offline, every host that is supposed to have redundant pieces of the file in the collaborating group will lose the file.
This will result in penalties for the hosts, but also results in a much higher liklihood of corruption of the file.

It is not certain that this can be avoided, though hopefully it can be discouraged.

\section{False Redundancy}

The network expects that hosts will go offline in a randomly distributed manner.
There are penalties if hosts go offline simultaneously, and they are called 'false redundancy penalties.'
There are two priciple ways that hosts would go down simultaneously.
The first is if they are delegating files.
The second is if all of the hosts are in the same geographic location, and some disaster like a power outage happens.

There may be other situations that cause hosts to go offline together.
All such situations are viewed by the network as unacceptable and are penalized.

The severities of these penalties have not been decided.
It has also not been determined how to measure false redundancy.

\begin{center}
Pentalty stuff here
\end{center}

\section{Entropy}

Each block, a random file segment must be selected.
This means that the blockchain needs an unpredictable way to produce entropy, otherwise a dishonest host could look ahead and only store the pieces that it knows will be "randomly" selected.
Each block, every host will be required to produce a random string that is 32 bytes in length.
There are no requirements on how this is to be done, but it is assumed that honest hosts will have a legitamate method for producing random strings.

Just like the proof of access, the random strings will have two stages.
In the first stage, only the hash of the randomly generated string will be revealed.
In the second stage, the actual random string will be revealed, and then all of the random strings will be appended deterministically and then hashed to produce the final random string for the block.

By determining entropy this way, we guarantee that if even a single host produces a random string, the final string will also be random.

This method of generating entropy is vulnerable to an attack: dishonest hosts can intentionally withdraw from the network to influence the outcome of the random number.
The way to prevent this is to make sure that the penalty for missing a heartbeat is more expenive than favorably generating entropy for a potential 80\% of dishonest hosts.
There will be a penalty for missing heartbeats, and it will sufficiently satisfy this attack prevention mechanism.

\begin{center}
Pentalty stuff here
\end{center}

\section{Script Wallets}

Wallets on Sia have a balance and a set of scripts.
These wallets are responsible for every interaction between Sia and external entities.
The scripts manage these interactions.

In addition to some general computational commands, scripts have system calls including

\begin{description}
	\item[Send(amount)] \hfill \\
	Send money from this wallet to another wallet on the network. \\
	Will only send money to existing wallets. \\
	Returns 'yes' if successful, 'no' if unsuccessful.
	\item[Rent(volume)] \hfill \\
	Rent a volume of storage from the Sia network. \\
	Returns a pointer to the file.
	\item[RentProtected(volume)] \hfill \\
	Rent a volume of storage from Sia that is write-only. \\
	Returns a pointer t othe file.
	\item[Release(filePointer)] \hfill \\
	Release a file from the network. \\
	You can only release files that you own.
	\item[Endorse(filePointer, amount)] \hfill \\
	Sends a volume of money to a file, which will be used to pay for the file in the future. \\
	If the file is not protected, the file will be copied and the new file will be protected. \\
	This amount can never be withdrawn from the file, and the file cannot be deleted until this amount is consumed.
\end{description}

Wallets consume file storage space on the network.
Just like files are charged for consuming space, wallets are charged the same price.

\section{Updates}

An update is a message to the network that needs to be processed.
Messages can include money sends, file rents, or announcements of new hosts.
Hosts are incentivised to include all updates into their heartbeats, because updates include small monetary compensation.
The compensation comes from the entity submitting the update.
This means that only entities with wallets on the local blockchain can submit updates.

% need to talk about uploading and downloading files, and perhaps fast-process updates.
% I think all of this should come after defining the tree though.

\section{Full Heartbeat}

A full heartbeat will contain the following:

\begin{itemize}
	\item Blockchain
	\item Parent Block
	\item Host Id
	\item File Proof Hash - Stage 1
	\item File Proof String - Stage 2
	\item Entropy Proof Hash - Stage 1
	\item Entropy Proof String - Stage 2
	\item Update List
	\item Host Signature
\end{itemize}

\section{A Tree of Blockchains}

Blockchains are organized into a tree shape, where \childrenperparent{} blockchains share a parent blockchain.
The parent blockchains do not handle updates or store files, and are composed of a random set of hosts chosen from among their children.
Parents of parents are also composed of random child hosts, but they are composed of a different set of hosts from the leafs - no host ever participates in more than a single leaf blockchain and a single parent blockchain.

The tree is how hosts can be confident that their siacoins are real and confirmed without needing to know every transaction on the network.
Each parent keeps track of the aggregate balance of all the children.

\section{Appendix: Vocabulary}

\begin{description}
	\item[Segment] \hfill \\
	An erasure coded piece of a physical file held by a single participant.
	\item[Sector] \hfill \\
	A logical block of data stored on a quorum.
	This logical block is composed of a set of equal sized erasure coded segments, one segment held by each participant in the quorum housing the Sector.
	\item[Ring] \hfill \\
	A physical block of erasure coded data.
	A ring is every segment for a particular file in a quorum.
	A ring is what the data looks like after it has been erasure coded; a sector is what the data looks like before it has been erasure coded.
	
	\item[Participant] \hfill \\
	A network-connected computer offering a discreet and nonflexible volume of storage to the network.
	\item[Quorum] \hfill \\
	A set of randomly chosen particpants working in consenses to monitor a fragment of the Sia network.
	\item[State] \hfill \\
	The status of a quorum-monitored fragment of the Sia network.
	Every participant in the same quorum will have an identical state.
	Every quorum has a different state, as every quorum monitors a different fragment of the Sia network.

	\item[Block] \hfill \\
	A set of updates to the State of a particular quorum.
	\item[Heartbeat] \hfill \\
	A set of updates from a single participant in a quorum.
	A block is actually just a list of heartbeats, one from every participant in the quorum that the block acts upon.
\end{description}

\end{document}

